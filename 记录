
////////////////////////////////////////////

树的子结构
    // 之前漏掉这句
        if(!pRoot1) return false;

////////////////////////////////////////////

调整数组顺序使奇数位于偶数前面
    Solution2

////////////////////////////////////////////

二叉搜索树的后序遍历序列
	Solution2 的解法很好


////////////////////////////////////////////

二叉树中和为某一值的路径
有两点需要注意：

1.void helper(vector<vector<int> >& res, vector<int>& cur, int& k)
这三个 & 均不能省略

2.切记 在和中减掉	k -= root->left->val;
if (root->left) {
	helper(root->left, expectNumber, res, cur, k);
	cur.pop_back(); 
	k -= root->left->val;
}


////////////////////////////////////////////

字符串的排列 （全排列）
注意去重

////////////////////////////////////////////

二叉搜索树与双向链表
题意为 将树的左右子树指针修改为双向链表的指针

需要注意的是 
1.该题 的验证方法 竟然还需要从右到左 
2.还有中序遍历时的处理

////////////////////////////////////////////



