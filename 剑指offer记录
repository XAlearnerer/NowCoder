

//================================== 剑指offer ================================================

////////////////////////////////////////////

树的子结构
    // 之前漏掉这句
        if(!pRoot1) return false;

////////////////////////////////////////////

调整数组顺序使奇数位于偶数前面
    Solution2

////////////////////////////////////////////

二叉搜索树的后序遍历序列
	Solution2 的解法很好


////////////////////////////////////////////

二叉树中和为某一值的路径
有两点需要注意：

1.void helper(vector<vector<int> >& res, vector<int>& cur, int& k)
这三个 & 均不能省略

2.切记 在和中减掉	k -= root->left->val;
if (root->left) {
	helper(root->left, expectNumber, res, cur, k);
	cur.pop_back(); 
	k -= root->left->val;
}


////////////////////////////////////////////

字符串的排列 （全排列）
注意去重

////////////////////////////////////////////

二叉搜索树与双向链表
题意为 将树的左右子树指针修改为双向链表的指针

需要注意的是 
1.该题 的验证方法 竟然还需要从右到左 
2.还有中序遍历时的处理

////////////////////////////////////////////


二叉搜索树的第k个结点
取巧通过 需要再看


////////////////////////////////////////////

数组中只出现一次的数字

其中 将数组分成2份的思想



////////////////////////////////////////////

正则表达式匹配
if ((*str != '\0') &&(*(str + 1) == '\0') && (*str == *pattern || *pattern == '.'))
之前少了 (*str != '\0') 就出错


////////////////////////////////////////////

!!  ====  序列化二叉树  ====
strcpy
strcat

////////////////////////////////////////////


数组中的逆序对
??? 完全没有思路

////////////////////////////////////////////

整数中1出现的次数（从1到n整数中1出现的次数）
不会了


////////////////////////////////////////////

孩子们的游戏(圆圈中最后剩下的数)

注意 v的size() 变化 
list的使用






