#include<iostream>
#include<map>
#include<set>

using namespace std;
map<long, long> m;


//////////////////////////////////////////////////////////////////////////////

// 牛客通过代码

long solve(long n) {  //记忆搜索法
	if (m.count(n)) return m[n]; //如果已有直接返回
	long count = 0;
	if ((n & 1) != 1) count = solve(n >> 1) + solve((n >> 1) - 1);  //n为偶数
	else count = solve(n >> 1);  //n为奇数
	m[n] = count;
	return count;
}

int main_pincouyingbi() {
	m[0] = 1; m[1] = 1;  //初始值
	long n; cin >> n;
	cout << solve(n) << endl;
	return 0;
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


// http://www.voidcn.com/article/p-vntahwvf-brp.html

//这道题我们应该理解为是要进行一种加法，和已经给定为n。
//然后我们现在有很多种2的k次方的值，要找出所有能加出n的方案。
//考虑到我们要加的数都是些2的k次方数，
//这其实跟二进制的位数相加很像，每个硬币都是二进制位数上的一位，
//而且我们恰好不同种硬币各有两个，即有两个2 ^ 0、两个2 ^ 1、两个2 ^ 2……
//把这些硬币等分成两份，正好就是两个二进制数，
//所以可以相当于两个二进制数数相加要得到n（大家自己看下图悟一下）
//
//
//我们的硬币等分成两行，每一个硬币都是每行上的一个0，
//因此这就是两个长度为log2(n)的二进制数的相加，和为长度为log2(n) + 1的数且首位为1其余位为0。
//现在，再将上面图中的两行用十进制的眼光来看，
//就是十进制要加出个n总共有多少种组合方式，这个就是小学题了，
//比如n为8，有0 + 8，1 + 7，2 + 6，3 + 5，4 + 4。
//走到这你就可以理解这份代码了，我们只需要注意两点：
//①、假如n为8，是允许如1000和000相加的情况的，也就是硬币8和0（不拿）。
//②、111 + 001（硬币421和硬币1）和101 + 011（硬币41和硬币21），
//只是前者选了第一行中面值为1的硬币，后者选了第二行中面值为1的硬币，
//本质上都得算同一种组合方法，也就是4211和4211都是同一种分法。
//因此我们可以考虑使用二进制异或来对这种类型进行去重（这样上0下1和上1下0结果都一样了）。
//结果都一样后方案还是双份的呀，怎么变成一份呢。
//可以用set（注意这个容器）来保存抑或结果，这样就去重变成一份了。


// 比如 ：6 有三种
// 0+6  000+110  异或后  110  
// 1+5  001+101  异或后  100
// 2+4  010+100  异或后  110
// 3+3  011+011  异或后  000
// 
// 可见 0+6 与 2+4 一致，均为一个2，一个4 

int main_pincouyingbi2()  //时间超时。。。。
{
	long n;
	cin >> n;
	set<long> s;
	for (long i = 0; i <= n / 2; ++i)
	{
		long cur = i ^ (n - i);
		s.insert(cur);
	}
	cout << s.size() << endl;
	return 0;
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////







